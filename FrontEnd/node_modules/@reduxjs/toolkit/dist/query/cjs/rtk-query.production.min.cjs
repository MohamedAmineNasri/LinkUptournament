"use strict";var ce=Object.defineProperty;var it=Object.getOwnPropertyDescriptor;var ot=Object.getOwnPropertyNames;var at=Object.prototype.hasOwnProperty;var st=(e,n)=>{for(var p in n)ce(e,p,{get:n[p],enumerable:!0})},ut=(e,n,p,T)=>{if(n&&typeof n=="object"||typeof n=="function")for(let c of ot(n))!at.call(e,c)&&c!==p&&ce(e,c,{get:()=>n[c],enumerable:!(T=it(n,c))||T.enumerable});return e};var yt=e=>ut(ce({},"__esModule",{value:!0}),e);var Rt={};st(Rt,{QueryStatus:()=>ie,buildCreateApi:()=>de,copyWithStructuralSharing:()=>G,coreModule:()=>pe,coreModuleName:()=>re,createApi:()=>rt,defaultSerializeQueryArgs:()=>ne,fakeBaseQuery:()=>Le,fetchBaseQuery:()=>be,retry:()=>Me,setupListeners:()=>ke,skipToken:()=>te});module.exports=yt(Rt);var ie=(c=>(c.uninitialized="uninitialized",c.pending="pending",c.fulfilled="fulfilled",c.rejected="rejected",c))(ie||{});function Te(e){return{status:e,isUninitialized:e==="uninitialized",isLoading:e==="pending",isSuccess:e==="fulfilled",isError:e==="rejected"}}function he(e){return new RegExp("(^|:)//").test(e)}var dt=e=>e.replace(/\/$/,""),pt=e=>e.replace(/^\//,"");function Qe(e,n){if(!e)return n;if(!n)return e;if(he(n))return n;let p=e.endsWith("/")||!n.startsWith("?")?"/":"";return e=dt(e),n=pt(n),`${e}${p}${n}`}var le=e=>[].concat(...e);function Re(){return typeof navigator>"u"||navigator.onLine===void 0?!0:navigator.onLine}function xe(){return typeof document>"u"?!0:document.visibilityState!=="hidden"}var o=require("@reduxjs/toolkit");var Se=o.isPlainObject;function G(e,n){if(e===n||!(Se(e)&&Se(n)||Array.isArray(e)&&Array.isArray(n)))return n;let p=Object.keys(n),T=Object.keys(e),c=p.length===T.length,x=Array.isArray(n)?[]:{};for(let A of p)x[A]=G(e[A],n[A]),c&&(c=e[A]===x[A]);return c?e:x}var Ae=(...e)=>fetch(...e),ct=e=>e.status>=200&&e.status<=299,lt=e=>/ion\/(vnd\.api\+)?json/.test(e.get("content-type")||"");function De(e){if(!(0,o.isPlainObject)(e))return e;let n={...e};for(let[p,T]of Object.entries(n))T===void 0&&delete n[p];return n}function be({baseUrl:e,prepareHeaders:n=d=>d,fetchFn:p=Ae,paramsSerializer:T,isJsonContentType:c=lt,jsonContentType:x="application/json",jsonReplacer:A,timeout:E,responseHandler:k,validateStatus:g,...h}={}){return typeof fetch>"u"&&p===Ae&&console.warn("Warning: `fetch` is not available. Please supply a custom `fetchFn` property to use `fetchBaseQuery` on SSR environments."),async(i,t)=>{let{signal:l,getState:S,extra:f,endpoint:y,forced:a,type:s}=t,r,{url:u,headers:Q=new Headers(h.headers),params:m=void 0,responseHandler:R=k??"json",validateStatus:M=g??ct,timeout:D=E,...v}=typeof i=="string"?{url:i}:i,b={...h,signal:l,...v};Q=new Headers(De(Q)),b.headers=await n(Q,{getState:S,extra:f,endpoint:y,forced:a,type:s})||Q;let B=F=>typeof F=="object"&&((0,o.isPlainObject)(F)||Array.isArray(F)||typeof F.toJSON=="function");if(!b.headers.has("content-type")&&B(b.body)&&b.headers.set("content-type",x),B(b.body)&&c(b.headers)&&(b.body=JSON.stringify(b.body,A)),m){let F=~u.indexOf("?")?"&":"?",w=T?T(m):new URLSearchParams(De(m));u+=F+w}u=Qe(e,u);let P=new Request(u,b);r={request:new Request(u,b)};let O,N=!1,I=D&&setTimeout(()=>{N=!0,t.abort()},D);try{O=await p(P)}catch(F){return{error:{status:N?"TIMEOUT_ERROR":"FETCH_ERROR",error:String(F)},meta:r}}finally{I&&clearTimeout(I)}let K=O.clone();r.response=K;let q,J="";try{let F;if(await Promise.all([d(O,R).then(w=>q=w,w=>F=w),K.text().then(w=>J=w,()=>{})]),F)throw F}catch(F){return{error:{status:"PARSING_ERROR",originalStatus:O.status,data:J,error:String(F)},meta:r}}return M(O,q)?{data:q,meta:r}:{error:{status:O.status,data:q},meta:r}};async function d(i,t){if(typeof t=="function")return t(i);if(t==="content-type"&&(t=c(i.headers)?"json":"text"),t==="json"){let l=await i.text();return l.length?JSON.parse(l):null}return i.text()}}var j=class{constructor(n,p=void 0){this.value=n;this.meta=p}};async function ft(e=0,n=5){let p=Math.min(e,n),T=~~((Math.random()+.4)*(300<<p));await new Promise(c=>setTimeout(x=>c(x),T))}function mt(e){throw Object.assign(new j({error:e}),{throwImmediately:!0})}var Ee={},gt=(e,n)=>async(p,T,c)=>{let x=[5,(n||Ee).maxRetries,(c||Ee).maxRetries].filter(h=>h!==void 0),[A]=x.slice(-1),k={maxRetries:A,backoff:ft,retryCondition:(h,d,{attempt:i})=>i<=A,...n,...c},g=0;for(;;)try{let h=await e(p,T,c);if(h.error)throw new j(h);return h}catch(h){if(g++,h.throwImmediately){if(h instanceof j)return h.value;throw h}if(h instanceof j&&!k.retryCondition(h.value.error,p,{attempt:g,baseQueryApi:T,extraOptions:c}))return h.value;await k.backoff(g,k.maxRetries)}},Me=Object.assign(gt,{fail:mt});var _=(0,o.createAction)("__rtkq/focused"),W=(0,o.createAction)("__rtkq/unfocused"),L=(0,o.createAction)("__rtkq/online"),V=(0,o.createAction)("__rtkq/offline"),fe=!1;function ke(e,n){function p(){let T=()=>e(_()),c=()=>e(W()),x=()=>e(L()),A=()=>e(V()),E=()=>{window.document.visibilityState==="visible"?T():c()};return fe||typeof window<"u"&&window.addEventListener&&(window.addEventListener("visibilitychange",E,!1),window.addEventListener("focus",T,!1),window.addEventListener("online",x,!1),window.addEventListener("offline",A,!1),fe=!0),()=>{window.removeEventListener("focus",T),window.removeEventListener("visibilitychange",E),window.removeEventListener("online",x),window.removeEventListener("offline",A),fe=!1}}return n?n(e,{onFocus:_,onFocusLost:W,onOffline:V,onOnline:L}):p()}function ae(e){return e.type==="query"}function ve(e){return e.type==="mutation"}function Y(e,n,p,T,c,x){return Tt(e)?e(n,p,T,c).map(oe).map(x):Array.isArray(e)?e.map(oe).map(x):[]}function Tt(e){return typeof e=="function"}function oe(e){return typeof e=="string"?{type:e}:e}var Lt=require("@reduxjs/toolkit");function me(e){return e!=null}function U(e){let n=0;for(let p in e)n++;return n}function Be(e,n){return e.catch(n)}var $=Symbol("forceQueryFn"),X=e=>typeof e[$]=="function";function Pe({serializeQueryArgs:e,queryThunk:n,mutationThunk:p,api:T,context:c}){let x=new Map,A=new Map,{unsubscribeQueryResult:E,removeMutationResult:k,updateSubscriptionOptions:g}=T.internalActions;return{buildInitiateQuery:S,buildInitiateMutation:f,getRunningQueryThunk:h,getRunningMutationThunk:d,getRunningQueriesThunk:i,getRunningMutationsThunk:t};function h(y,a){return s=>{let r=c.endpointDefinitions[y],u=e({queryArgs:a,endpointDefinition:r,endpointName:y});return x.get(s)?.[u]}}function d(y,a){return s=>A.get(s)?.[a]}function i(){return y=>Object.values(x.get(y)||{}).filter(me)}function t(){return y=>Object.values(A.get(y)||{}).filter(me)}function l(y){}function S(y,a){let s=(r,{subscribe:u=!0,forceRefetch:Q,subscriptionOptions:m,[$]:R,...M}={})=>(D,v)=>{let b=e({queryArgs:r,endpointDefinition:a,endpointName:y}),B=n({...M,type:"query",subscribe:u,forceRefetch:Q,subscriptionOptions:m,endpointName:y,originalArgs:r,queryCacheKey:b,[$]:R}),P=T.endpoints[y].select(r),C=D(B),O=P(v());let{requestId:N,abort:I}=C,K=O.requestId!==N,q=x.get(D)?.[b],J=()=>P(v()),F=Object.assign(R?C.then(J):K&&!q?Promise.resolve(O):Promise.all([q,C]).then(J),{arg:r,requestId:N,subscriptionOptions:m,queryCacheKey:b,abort:I,async unwrap(){let w=await F;if(w.isError)throw w.error;return w.data},refetch:()=>D(s(r,{subscribe:!1,forceRefetch:!0})),unsubscribe(){u&&D(E({queryCacheKey:b,requestId:N}))},updateSubscriptionOptions(w){F.subscriptionOptions=w,D(g({endpointName:y,requestId:N,queryCacheKey:b,options:w}))}});if(!q&&!K&&!R){let w=x.get(D)||{};w[b]=F,x.set(D,w),F.then(()=>{delete w[b],U(w)||x.delete(D)})}return F};return s}function f(y){return(a,{track:s=!0,fixedCacheKey:r}={})=>(u,Q)=>{let m=p({type:"mutation",endpointName:y,originalArgs:a,track:s,fixedCacheKey:r}),R=u(m);let{requestId:M,abort:D,unwrap:v}=R,b=Be(R.unwrap().then(O=>({data:O})),O=>({error:O})),B=()=>{u(k({requestId:M,fixedCacheKey:r}))},P=Object.assign(b,{arg:R.arg,requestId:M,abort:D,unwrap:v,reset:B}),C=A.get(u)||{};return A.set(u,C),C[M]=P,P.then(()=>{delete C[M],U(C)||A.delete(u)}),r&&(C[r]=P,P.then(()=>{C[r]===P&&(delete C[r],U(C)||A.delete(u))})),P}}}var se=require("immer");function Fe(e){return e}function we({reducerPath:e,baseQuery:n,context:{endpointDefinitions:p},serializeQueryArgs:T,api:c,assertTagType:x}){let A=(a,s,r,u)=>(Q,m)=>{let R=p[a],M=T({queryArgs:s,endpointDefinition:R,endpointName:a});if(Q(c.internalActions.queryResultPatched({queryCacheKey:M,patches:r})),!u)return;let D=c.endpoints[a].select(s)(m()),v=Y(R.providesTags,D.data,void 0,s,{},x);Q(c.internalActions.updateProvidedBy({queryCacheKey:M,providedTags:v}))},E=(a,s,r,u=!0)=>(Q,m)=>{let M=c.endpoints[a].select(s)(m()),D={patches:[],inversePatches:[],undo:()=>Q(c.util.patchQueryData(a,s,D.inversePatches,u))};if(M.status==="uninitialized")return D;let v;if("data"in M)if((0,se.isDraftable)(M.data)){let[b,B,P]=(0,se.produceWithPatches)(M.data,r);D.patches.push(...B),D.inversePatches.push(...P),v=b}else v=r(M.data),D.patches.push({op:"replace",path:[],value:v}),D.inversePatches.push({op:"replace",path:[],value:M.data});return Q(c.util.patchQueryData(a,s,D.patches,u)),D},k=(a,s,r)=>u=>u(c.endpoints[a].initiate(s,{subscribe:!1,forceRefetch:!0,[$]:()=>({data:r})})),g=async(a,{signal:s,abort:r,rejectWithValue:u,fulfillWithValue:Q,dispatch:m,getState:R,extra:M})=>{let D=p[a.endpointName];try{let v=Fe,b,B={signal:s,abort:r,dispatch:m,getState:R,extra:M,endpoint:a.endpointName,type:a.type,forced:a.type==="query"?h(a,R()):void 0},P=a.type==="query"?a[$]:void 0;if(P?b=P():D.query?(b=await n(D.query(a.originalArgs),B,D.extraOptions),D.transformResponse&&(v=D.transformResponse)):b=await D.queryFn(a.originalArgs,B,D.extraOptions,C=>n(C,B,D.extraOptions)),typeof process<"u",b.error)throw new j(b.error,b.meta);return Q(await v(b.data,b.meta,a.originalArgs),{fulfilledTimeStamp:Date.now(),baseQueryMeta:b.meta,[o.SHOULD_AUTOBATCH]:!0})}catch(v){let b=v;if(b instanceof j){let B=Fe;D.query&&D.transformErrorResponse&&(B=D.transformErrorResponse);try{return u(await B(b.value,b.meta,a.originalArgs),{baseQueryMeta:b.meta,[o.SHOULD_AUTOBATCH]:!0})}catch(P){b=P}}throw typeof process<"u",console.error(b),b}};function h(a,s){let r=s[e]?.queries?.[a.queryCacheKey],u=s[e]?.config.refetchOnMountOrArgChange,Q=r?.fulfilledTimeStamp,m=a.forceRefetch??(a.subscribe&&u);return m?m===!0||(Number(new Date)-Number(Q))/1e3>=m:!1}let d=(0,o.createAsyncThunk)(`${e}/executeQuery`,g,{getPendingMeta(){return{startedTimeStamp:Date.now(),[o.SHOULD_AUTOBATCH]:!0}},condition(a,{getState:s}){let r=s(),u=r[e]?.queries?.[a.queryCacheKey],Q=u?.fulfilledTimeStamp,m=a.originalArgs,R=u?.originalArgs,M=p[a.endpointName];return X(a)?!0:u?.status==="pending"?!1:h(a,r)||ae(M)&&M?.forceRefetch?.({currentArg:m,previousArg:R,endpointState:u,state:r})?!0:!Q},dispatchConditionRejection:!0}),i=(0,o.createAsyncThunk)(`${e}/executeMutation`,g,{getPendingMeta(){return{startedTimeStamp:Date.now(),[o.SHOULD_AUTOBATCH]:!0}}}),t=a=>"force"in a,l=a=>"ifOlderThan"in a,S=(a,s,r)=>(u,Q)=>{let m=t(r)&&r.force,R=l(r)&&r.ifOlderThan,M=(v=!0)=>{let b={forceRefetch:v,isPrefetch:!0};return c.endpoints[a].initiate(s,b)},D=c.endpoints[a].select(s)(Q());if(m)u(M());else if(R){let v=D?.fulfilledTimeStamp;if(!v){u(M());return}(Number(new Date)-Number(new Date(v)))/1e3>=R&&u(M())}else u(M(!1))};function f(a){return s=>s?.meta?.arg?.endpointName===a}function y(a,s){return{matchPending:(0,o.isAllOf)((0,o.isPending)(a),f(s)),matchFulfilled:(0,o.isAllOf)((0,o.isFulfilled)(a),f(s)),matchRejected:(0,o.isAllOf)((0,o.isRejected)(a),f(s))}}return{queryThunk:d,mutationThunk:i,prefetch:S,updateQueryData:E,upsertQueryData:k,patchQueryData:A,buildMatchThunkActions:y}}function ue(e,n,p,T){return Y(p[e.meta.arg.endpointName][n],(0,o.isFulfilled)(e)?e.payload:void 0,(0,o.isRejectedWithValue)(e)?e.payload:void 0,e.meta.arg.originalArgs,"baseQueryMeta"in e.meta?e.meta.baseQueryMeta:void 0,T)}var Ie=require("immer"),ee=require("immer");function ye(e,n,p){let T=e[n];T&&p(T)}function z(e){return("arg"in e?e.arg.fixedCacheKey:e.fixedCacheKey)??e.requestId}function Ce(e,n,p){let T=e[z(n)];T&&p(T)}var Z={};function Oe({reducerPath:e,queryThunk:n,mutationThunk:p,context:{endpointDefinitions:T,apiUid:c,extractRehydrationInfo:x,hasRehydrationInfo:A},assertTagType:E,config:k}){let g=(0,o.createAction)(`${e}/resetApiState`),h=(0,o.createSlice)({name:`${e}/queries`,initialState:Z,reducers:{removeQueryResult:{reducer(s,{payload:{queryCacheKey:r}}){delete s[r]},prepare:(0,o.prepareAutoBatched)()},queryResultPatched:{reducer(s,{payload:{queryCacheKey:r,patches:u}}){ye(s,r,Q=>{Q.data=(0,ee.applyPatches)(Q.data,u.concat())})},prepare:(0,o.prepareAutoBatched)()}},extraReducers(s){s.addCase(n.pending,(r,{meta:u,meta:{arg:Q}})=>{let m=X(Q);r[Q.queryCacheKey]??={status:"uninitialized",endpointName:Q.endpointName},ye(r,Q.queryCacheKey,R=>{R.status="pending",R.requestId=m&&R.requestId?R.requestId:u.requestId,Q.originalArgs!==void 0&&(R.originalArgs=Q.originalArgs),R.startedTimeStamp=u.startedTimeStamp})}).addCase(n.fulfilled,(r,{meta:u,payload:Q})=>{ye(r,u.arg.queryCacheKey,m=>{if(m.requestId!==u.requestId&&!X(u.arg))return;let{merge:R}=T[u.arg.endpointName];if(m.status="fulfilled",R)if(m.data!==void 0){let{fulfilledTimeStamp:M,arg:D,baseQueryMeta:v,requestId:b}=u,B=(0,o.createNextState)(m.data,P=>R(P,Q,{arg:D.originalArgs,baseQueryMeta:v,fulfilledTimeStamp:M,requestId:b}));m.data=B}else m.data=Q;else m.data=T[u.arg.endpointName].structuralSharing??!0?G((0,Ie.isDraft)(m.data)?(0,ee.original)(m.data):m.data,Q):Q;delete m.error,m.fulfilledTimeStamp=u.fulfilledTimeStamp})}).addCase(n.rejected,(r,{meta:{condition:u,arg:Q,requestId:m},error:R,payload:M})=>{ye(r,Q.queryCacheKey,D=>{if(!u){if(D.requestId!==m)return;D.status="rejected",D.error=M??R}})}).addMatcher(A,(r,u)=>{let{queries:Q}=x(u);for(let[m,R]of Object.entries(Q))(R?.status==="fulfilled"||R?.status==="rejected")&&(r[m]=R)})}}),d=(0,o.createSlice)({name:`${e}/mutations`,initialState:Z,reducers:{removeMutationResult:{reducer(s,{payload:r}){let u=z(r);u in s&&delete s[u]},prepare:(0,o.prepareAutoBatched)()}},extraReducers(s){s.addCase(p.pending,(r,{meta:u,meta:{requestId:Q,arg:m,startedTimeStamp:R}})=>{m.track&&(r[z(u)]={requestId:Q,status:"pending",endpointName:m.endpointName,startedTimeStamp:R})}).addCase(p.fulfilled,(r,{payload:u,meta:Q})=>{Q.arg.track&&Ce(r,Q,m=>{m.requestId===Q.requestId&&(m.status="fulfilled",m.data=u,m.fulfilledTimeStamp=Q.fulfilledTimeStamp)})}).addCase(p.rejected,(r,{payload:u,error:Q,meta:m})=>{m.arg.track&&Ce(r,m,R=>{R.requestId===m.requestId&&(R.status="rejected",R.error=u??Q)})}).addMatcher(A,(r,u)=>{let{mutations:Q}=x(u);for(let[m,R]of Object.entries(Q))(R?.status==="fulfilled"||R?.status==="rejected")&&m!==R?.requestId&&(r[m]=R)})}}),i=(0,o.createSlice)({name:`${e}/invalidation`,initialState:Z,reducers:{updateProvidedBy:{reducer(s,r){let{queryCacheKey:u,providedTags:Q}=r.payload;for(let m of Object.values(s))for(let R of Object.values(m)){let M=R.indexOf(u);M!==-1&&R.splice(M,1)}for(let{type:m,id:R}of Q){let M=(s[m]??={})[R||"__internal_without_id"]??=[];M.includes(u)||M.push(u)}},prepare:(0,o.prepareAutoBatched)()}},extraReducers(s){s.addCase(h.actions.removeQueryResult,(r,{payload:{queryCacheKey:u}})=>{for(let Q of Object.values(r))for(let m of Object.values(Q)){let R=m.indexOf(u);R!==-1&&m.splice(R,1)}}).addMatcher(A,(r,u)=>{let{provided:Q}=x(u);for(let[m,R]of Object.entries(Q))for(let[M,D]of Object.entries(R)){let v=(r[m]??={})[M||"__internal_without_id"]??=[];for(let b of D)v.includes(b)||v.push(b)}}).addMatcher((0,o.isAnyOf)((0,o.isFulfilled)(n),(0,o.isRejectedWithValue)(n)),(r,u)=>{let Q=ue(u,"providesTags",T,E),{queryCacheKey:m}=u.meta.arg;i.caseReducers.updateProvidedBy(r,i.actions.updateProvidedBy({queryCacheKey:m,providedTags:Q}))})}}),t=(0,o.createSlice)({name:`${e}/subscriptions`,initialState:Z,reducers:{updateSubscriptionOptions(s,r){},unsubscribeQueryResult(s,r){},internal_getRTKQSubscriptions(){}}}),l=(0,o.createSlice)({name:`${e}/internalSubscriptions`,initialState:Z,reducers:{subscriptionsUpdated:{reducer(s,r){return(0,ee.applyPatches)(s,r.payload)},prepare:(0,o.prepareAutoBatched)()}}}),S=(0,o.createSlice)({name:`${e}/config`,initialState:{online:Re(),focused:xe(),middlewareRegistered:!1,...k},reducers:{middlewareRegistered(s,{payload:r}){s.middlewareRegistered=s.middlewareRegistered==="conflict"||c!==r?"conflict":!0}},extraReducers:s=>{s.addCase(L,r=>{r.online=!0}).addCase(V,r=>{r.online=!1}).addCase(_,r=>{r.focused=!0}).addCase(W,r=>{r.focused=!1}).addMatcher(A,r=>({...r}))}}),f=(0,o.combineReducers)({queries:h.reducer,mutations:d.reducer,provided:i.reducer,subscriptions:l.reducer,config:S.reducer}),y=(s,r)=>f(g.match(r)?void 0:s,r),a={...S.actions,...h.actions,...t.actions,...l.actions,...d.actions,...i.actions,resetApiState:g};return{reducer:y,actions:a}}var te=Symbol.for("RTKQ/skipToken"),Ke={status:"uninitialized"},qe=(0,o.createNextState)(Ke,()=>{}),Ne=(0,o.createNextState)(Ke,()=>{});function je({serializeQueryArgs:e,reducerPath:n,createSelector:p}){let T=d=>qe,c=d=>Ne;return{buildQuerySelector:E,buildMutationSelector:k,selectInvalidatedBy:g,selectCachedArgsForQuery:h};function x(d){return{...d,...Te(d.status)}}function A(d){return d[n]}function E(d,i){return t=>{let l=e({queryArgs:t,endpointDefinition:i,endpointName:d});return p(t===te?T:y=>A(y)?.queries?.[l]??qe,x)}}function k(){return d=>{let i;return typeof d=="object"?i=z(d)??te:i=d,p(i===te?c:S=>A(S)?.mutations?.[i]??Ne,x)}}function g(d,i){let t=d[n],l=new Set;for(let S of i.map(oe)){let f=t.provided[S.type];if(!f)continue;let y=(S.id!==void 0?f[S.id]:le(Object.values(f)))??[];for(let a of y)l.add(a)}return le(Array.from(l.values()).map(S=>{let f=t.queries[S];return f?[{queryCacheKey:S,endpointName:f.endpointName,originalArgs:f.originalArgs}]:[]}))}function h(d,i){return Object.values(d[n].queries).filter(t=>t?.endpointName===i&&t.status!=="uninitialized").map(t=>t.originalArgs)}}var He=require("@reduxjs/toolkit");var Ue=WeakMap?new WeakMap:void 0,ne=({endpointName:e,queryArgs:n})=>{let p="",T=Ue?.get(n);if(typeof T=="string")p=T;else{let c=JSON.stringify(n,(x,A)=>(0,o.isPlainObject)(A)?Object.keys(A).sort().reduce((E,k)=>(E[k]=A[k],E),{}):A);(0,o.isPlainObject)(n)&&Ue?.set(n,c),p=c}return`${e}(${p})`};var ge=require("reselect");function de(...e){return function(p){let T=(0,ge.weakMapMemoize)(g=>p.extractRehydrationInfo?.(g,{reducerPath:p.reducerPath??"api"})),c={reducerPath:"api",keepUnusedDataFor:60,refetchOnMountOrArgChange:!1,refetchOnFocus:!1,refetchOnReconnect:!1,invalidationBehavior:"delayed",...p,extractRehydrationInfo:T,serializeQueryArgs(g){let h=ne;if("serializeQueryArgs"in g.endpointDefinition){let d=g.endpointDefinition.serializeQueryArgs;h=i=>{let t=d(i);return typeof t=="string"?t:ne({...i,queryArgs:t})}}else p.serializeQueryArgs&&(h=p.serializeQueryArgs);return h(g)},tagTypes:[...p.tagTypes||[]]},x={endpointDefinitions:{},batch(g){g()},apiUid:(0,o.nanoid)(),extractRehydrationInfo:T,hasRehydrationInfo:(0,ge.weakMapMemoize)(g=>T(g)!=null)},A={injectEndpoints:k,enhanceEndpoints({addTagTypes:g,endpoints:h}){if(g)for(let d of g)c.tagTypes.includes(d)||c.tagTypes.push(d);if(h)for(let[d,i]of Object.entries(h))typeof i=="function"?i(x.endpointDefinitions[d]):Object.assign(x.endpointDefinitions[d]||{},i);return A}},E=e.map(g=>g.init(A,c,x));function k(g){let h=g.endpoints({query:d=>({...d,type:"query"}),mutation:d=>({...d,type:"mutation"})});for(let[d,i]of Object.entries(h)){if(g.overrideExisting!==!0&&d in x.endpointDefinitions){if(g.overrideExisting==="throw")throw new Error((0,He.formatProdErrorMessage)(39));typeof process<"u";continue}x.endpointDefinitions[d]=i;for(let t of E)t.injectEndpoint(d,i)}return A}return A.injectEndpoints({endpoints:p.endpoints})}}var _e=require("@reduxjs/toolkit");function Le(){return function(){throw new Error((0,_e.formatProdErrorMessage)(33))}}function ht(e){for(let n in e)return!1;return!0}var Qt=2147483647/1e3-1,ze=({reducerPath:e,api:n,context:p,internalState:T})=>{let{removeQueryResult:c,unsubscribeQueryResult:x}=n.internalActions;function A(h){let d=T.currentSubscriptions[h];return!!d&&!ht(d)}let E={},k=(h,d,i)=>{if(x.match(h)){let t=d.getState()[e],{queryCacheKey:l}=h.payload;g(l,t.queries[l]?.endpointName,d,t.config)}if(n.util.resetApiState.match(h))for(let[t,l]of Object.entries(E))l&&clearTimeout(l),delete E[t];if(p.hasRehydrationInfo(h)){let t=d.getState()[e],{queries:l}=p.extractRehydrationInfo(h);for(let[S,f]of Object.entries(l))g(S,f?.endpointName,d,t.config)}};function g(h,d,i,t){let S=p.endpointDefinitions[d]?.keepUnusedDataFor??t.keepUnusedDataFor;if(S===1/0)return;let f=Math.max(0,Math.min(S,Qt));if(!A(h)){let y=E[h];y&&clearTimeout(y),E[h]=setTimeout(()=>{A(h)||i.dispatch(c({queryCacheKey:h})),delete E[h]},f*1e3)}}return k};var We=({reducerPath:e,context:n,context:{endpointDefinitions:p},mutationThunk:T,queryThunk:c,api:x,assertTagType:A,refetchQuery:E,internalState:k})=>{let{removeQueryResult:g}=x.internalActions,h=(0,o.isAnyOf)((0,o.isFulfilled)(T),(0,o.isRejectedWithValue)(T)),d=(0,o.isAnyOf)((0,o.isFulfilled)(T,c),(0,o.isRejected)(T,c)),i=[],t=(f,y)=>{h(f)?S(ue(f,"invalidatesTags",p,A),y):d(f)?S([],y):x.util.invalidateTags.match(f)&&S(Y(f.payload,void 0,void 0,void 0,void 0,A),y)};function l(f){for(let y in f.queries)if(f.queries[y]?.status==="pending")return!0;for(let y in f.mutations)if(f.mutations[y]?.status==="pending")return!0;return!1}function S(f,y){let a=y.getState(),s=a[e];if(i.push(...f),s.config.invalidationBehavior==="delayed"&&l(s))return;let r=i;if(i=[],r.length===0)return;let u=x.util.selectInvalidatedBy(a,r);n.batch(()=>{let Q=Array.from(u.values());for(let{queryCacheKey:m}of Q){let R=s.queries[m],M=k.currentSubscriptions[m]??{};R&&(U(M)===0?y.dispatch(g({queryCacheKey:m})):R.status!=="uninitialized"&&y.dispatch(E(R,m)))}})}return t};var Ve=({reducerPath:e,queryThunk:n,api:p,refetchQuery:T,internalState:c})=>{let x={},A=(i,t)=>{(p.internalActions.updateSubscriptionOptions.match(i)||p.internalActions.unsubscribeQueryResult.match(i))&&k(i.payload,t),(n.pending.match(i)||n.rejected.match(i)&&i.meta.condition)&&k(i.meta.arg,t),(n.fulfilled.match(i)||n.rejected.match(i)&&!i.meta.condition)&&E(i.meta.arg,t),p.util.resetApiState.match(i)&&h()};function E({queryCacheKey:i},t){let l=t.getState()[e],S=l.queries[i],f=c.currentSubscriptions[i];if(!S||S.status==="uninitialized")return;let{lowestPollingInterval:y,skipPollingIfUnfocused:a}=d(f);if(!Number.isFinite(y))return;let s=x[i];s?.timeout&&(clearTimeout(s.timeout),s.timeout=void 0);let r=Date.now()+y;x[i]={nextPollTimestamp:r,pollingInterval:y,timeout:setTimeout(()=>{(l.config.focused||!a)&&t.dispatch(T(S,i)),E({queryCacheKey:i},t)},y)}}function k({queryCacheKey:i},t){let S=t.getState()[e].queries[i],f=c.currentSubscriptions[i];if(!S||S.status==="uninitialized")return;let{lowestPollingInterval:y}=d(f);if(!Number.isFinite(y)){g(i);return}let a=x[i],s=Date.now()+y;(!a||s<a.nextPollTimestamp)&&E({queryCacheKey:i},t)}function g(i){let t=x[i];t?.timeout&&clearTimeout(t.timeout),delete x[i]}function h(){for(let i of Object.keys(x))g(i)}function d(i={}){let t=!1,l=Number.POSITIVE_INFINITY;for(let S in i)i[S].pollingInterval&&(l=Math.min(i[S].pollingInterval,l),t=i[S].skipPollingIfUnfocused||t);return{lowestPollingInterval:l,skipPollingIfUnfocused:t}}return A};var $e=({reducerPath:e,context:n,api:p,refetchQuery:T,internalState:c})=>{let{removeQueryResult:x}=p.internalActions,A=(k,g)=>{_.match(k)&&E(g,"refetchOnFocus"),L.match(k)&&E(g,"refetchOnReconnect")};function E(k,g){let h=k.getState()[e],d=h.queries,i=c.currentSubscriptions;n.batch(()=>{for(let t of Object.keys(i)){let l=d[t],S=i[t];if(!S||!l)continue;(Object.values(S).some(y=>y[g]===!0)||Object.values(S).every(y=>y[g]===void 0)&&h.config[g])&&(U(S)===0?k.dispatch(x({queryCacheKey:t})):l.status!=="uninitialized"&&k.dispatch(T(l,t)))}})}return A};var Je=new Error("Promise never resolved before cacheEntryRemoved."),Ge=({api:e,reducerPath:n,context:p,queryThunk:T,mutationThunk:c,internalState:x})=>{let A=(0,o.isAsyncThunkAction)(T),E=(0,o.isAsyncThunkAction)(c),k=(0,o.isFulfilled)(T,c),g={},h=(t,l,S)=>{let f=d(t);if(T.pending.match(t)){let y=S[n].queries[f],a=l.getState()[n].queries[f];!y&&a&&i(t.meta.arg.endpointName,t.meta.arg.originalArgs,f,l,t.meta.requestId)}else if(c.pending.match(t))l.getState()[n].mutations[f]&&i(t.meta.arg.endpointName,t.meta.arg.originalArgs,f,l,t.meta.requestId);else if(k(t)){let y=g[f];y?.valueResolved&&(y.valueResolved({data:t.payload,meta:t.meta.baseQueryMeta}),delete y.valueResolved)}else if(e.internalActions.removeQueryResult.match(t)||e.internalActions.removeMutationResult.match(t)){let y=g[f];y&&(delete g[f],y.cacheEntryRemoved())}else if(e.util.resetApiState.match(t))for(let[y,a]of Object.entries(g))delete g[y],a.cacheEntryRemoved()};function d(t){return A(t)?t.meta.arg.queryCacheKey:E(t)?t.meta.arg.fixedCacheKey??t.meta.requestId:e.internalActions.removeQueryResult.match(t)?t.payload.queryCacheKey:e.internalActions.removeMutationResult.match(t)?z(t.payload):""}function i(t,l,S,f,y){let a=p.endpointDefinitions[t],s=a?.onCacheEntryAdded;if(!s)return;let r={},u=new Promise(v=>{r.cacheEntryRemoved=v}),Q=Promise.race([new Promise(v=>{r.valueResolved=v}),u.then(()=>{throw Je})]);Q.catch(()=>{}),g[S]=r;let m=e.endpoints[t].select(a.type==="query"?l:S),R=f.dispatch((v,b,B)=>B),M={...f,getCacheEntry:()=>m(f.getState()),requestId:y,extra:R,updateCachedData:a.type==="query"?v=>f.dispatch(e.util.updateQueryData(t,l,v)):void 0,cacheDataLoaded:Q,cacheEntryRemoved:u},D=s(l,M);Promise.resolve(D).catch(v=>{if(v!==Je)throw v})}return h};var Ye=({api:e,context:n,queryThunk:p,mutationThunk:T})=>{let c=(0,o.isPending)(p,T),x=(0,o.isRejected)(p,T),A=(0,o.isFulfilled)(p,T),E={};return(g,h)=>{if(c(g)){let{requestId:d,arg:{endpointName:i,originalArgs:t}}=g.meta,l=n.endpointDefinitions[i],S=l?.onQueryStarted;if(S){let f={},y=new Promise((u,Q)=>{f.resolve=u,f.reject=Q});y.catch(()=>{}),E[d]=f;let a=e.endpoints[i].select(l.type==="query"?t:d),s=h.dispatch((u,Q,m)=>m),r={...h,getCacheEntry:()=>a(h.getState()),requestId:d,extra:s,updateCachedData:l.type==="query"?u=>h.dispatch(e.util.updateQueryData(i,t,u)):void 0,queryFulfilled:y};S(t,r)}}else if(A(g)){let{requestId:d,baseQueryMeta:i}=g.meta;E[d]?.resolve({data:g.payload,meta:i}),delete E[d]}else if(x(g)){let{requestId:d,rejectedWithValue:i,baseQueryMeta:t}=g.meta;E[d]?.reject({error:g.payload??g.error,isUnhandledError:!i,meta:t}),delete E[d]}}};var Xe=({api:e,context:{apiUid:n},reducerPath:p})=>(T,c)=>{e.util.resetApiState.match(T)&&c.dispatch(e.internalActions.middlewareRegistered(n)),typeof process<"u"};var Ze=require("immer");var et=({api:e,queryThunk:n,internalState:p})=>{let T=`${e.reducerPath}/subscriptions`,c=null,x=null,{updateSubscriptionOptions:A,unsubscribeQueryResult:E}=e.internalActions,k=(t,l)=>{if(A.match(l)){let{queryCacheKey:f,requestId:y,options:a}=l.payload;return t?.[f]?.[y]&&(t[f][y]=a),!0}if(E.match(l)){let{queryCacheKey:f,requestId:y}=l.payload;return t[f]&&delete t[f][y],!0}if(e.internalActions.removeQueryResult.match(l))return delete t[l.payload.queryCacheKey],!0;if(n.pending.match(l)){let{meta:{arg:f,requestId:y}}=l,a=t[f.queryCacheKey]??={};return a[`${y}_running`]={},f.subscribe&&(a[y]=f.subscriptionOptions??a[y]??{}),!0}let S=!1;if(n.fulfilled.match(l)||n.rejected.match(l)){let f=t[l.meta.arg.queryCacheKey]||{},y=`${l.meta.requestId}_running`;S||=!!f[y],delete f[y]}if(n.rejected.match(l)){let{meta:{condition:f,arg:y,requestId:a}}=l;if(f&&y.subscribe){let s=t[y.queryCacheKey]??={};s[a]=y.subscriptionOptions??s[a]??{},S=!0}}return S},g=()=>p.currentSubscriptions,i={getSubscriptions:g,getSubscriptionCount:t=>{let S=g()[t]??{};return U(S)},isRequestSubscribed:(t,l)=>!!g()?.[t]?.[l]};return(t,l)=>{if(c||(c=JSON.parse(JSON.stringify(p.currentSubscriptions))),e.util.resetApiState.match(t))return c=p.currentSubscriptions={},x=null,[!0,!1];if(e.internalActions.internal_getRTKQSubscriptions.match(t))return[!1,i];let S=k(p.currentSubscriptions,t),f=!0;if(S){x||(x=setTimeout(()=>{let s=JSON.parse(JSON.stringify(p.currentSubscriptions)),[,r]=(0,Ze.produceWithPatches)(c,()=>s);l.next(e.internalActions.subscriptionsUpdated(r)),c=s,x=null},500));let y=typeof t.type=="string"&&!!t.type.startsWith(T),a=n.rejected.match(t)&&t.meta.condition&&!!t.meta.arg.subscribe;f=!y&&!a}return[f,!1]}};function tt(e){let{reducerPath:n,queryThunk:p,api:T,context:c}=e,{apiUid:x}=c,A={invalidateTags:(0,o.createAction)(`${n}/invalidateTags`)},E=d=>d.type.startsWith(`${n}/`),k=[Xe,ze,We,Ve,Ge,Ye];return{middleware:d=>{let i=!1,l={...e,internalState:{currentSubscriptions:{}},refetchQuery:h,isThisApiSliceAction:E},S=k.map(a=>a(l)),f=et(l),y=$e(l);return a=>s=>{if(!(0,o.isAction)(s))return a(s);i||(i=!0,d.dispatch(T.internalActions.middlewareRegistered(x)));let r={...d,next:a},u=d.getState(),[Q,m]=f(s,r,u),R;if(Q?R=a(s):R=m,d.getState()[n]&&(y(s,r,u),E(s)||c.hasRehydrationInfo(s)))for(let M of S)M(s,r,u);return R}},actions:A};function h(d,i,t={}){return p({type:"query",endpointName:d.endpointName,originalArgs:d.originalArgs,subscribe:!1,forceRefetch:!0,queryCacheKey:i,...t})}}function H(e,...n){return Object.assign(e,...n)}var nt=require("immer");var re=Symbol(),pe=({createSelector:e=o.createSelector}={})=>({name:re,init(n,{baseQuery:p,tagTypes:T,reducerPath:c,serializeQueryArgs:x,keepUnusedDataFor:A,refetchOnMountOrArgChange:E,refetchOnFocus:k,refetchOnReconnect:g,invalidationBehavior:h},d){(0,nt.enablePatches)();let i=I=>(typeof process<"u",I);Object.assign(n,{reducerPath:c,endpoints:{},internalActions:{onOnline:L,onOffline:V,onFocus:_,onFocusLost:W},util:{}});let{queryThunk:t,mutationThunk:l,patchQueryData:S,updateQueryData:f,upsertQueryData:y,prefetch:a,buildMatchThunkActions:s}=we({baseQuery:p,reducerPath:c,context:d,api:n,serializeQueryArgs:x,assertTagType:i}),{reducer:r,actions:u}=Oe({context:d,queryThunk:t,mutationThunk:l,reducerPath:c,assertTagType:i,config:{refetchOnFocus:k,refetchOnReconnect:g,refetchOnMountOrArgChange:E,keepUnusedDataFor:A,reducerPath:c,invalidationBehavior:h}});H(n.util,{patchQueryData:S,updateQueryData:f,upsertQueryData:y,prefetch:a,resetApiState:u.resetApiState}),H(n.internalActions,u);let{middleware:Q,actions:m}=tt({reducerPath:c,context:d,queryThunk:t,mutationThunk:l,api:n,assertTagType:i});H(n.util,m),H(n,{reducer:r,middleware:Q});let{buildQuerySelector:R,buildMutationSelector:M,selectInvalidatedBy:D,selectCachedArgsForQuery:v}=je({serializeQueryArgs:x,reducerPath:c,createSelector:e});H(n.util,{selectInvalidatedBy:D,selectCachedArgsForQuery:v});let{buildInitiateQuery:b,buildInitiateMutation:B,getRunningMutationThunk:P,getRunningMutationsThunk:C,getRunningQueriesThunk:O,getRunningQueryThunk:N}=Pe({queryThunk:t,mutationThunk:l,api:n,serializeQueryArgs:x,context:d});return H(n.util,{getRunningMutationThunk:P,getRunningMutationsThunk:C,getRunningQueryThunk:N,getRunningQueriesThunk:O}),{name:re,injectEndpoint(I,K){let q=n;q.endpoints[I]??={},ae(K)?H(q.endpoints[I],{name:I,select:R(I,K),initiate:b(I,K)},s(t,I)):ve(K)&&H(q.endpoints[I],{name:I,select:M(),initiate:B(I)},s(l,I))}}}});var rt=de(pe());
//# sourceMappingURL=rtk-query.production.min.cjs.map