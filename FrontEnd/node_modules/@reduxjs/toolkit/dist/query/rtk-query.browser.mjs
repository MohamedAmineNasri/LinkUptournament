var he=(f=>(f.uninitialized="uninitialized",f.pending="pending",f.fulfilled="fulfilled",f.rejected="rejected",f))(he||{});function Ee(e){return{status:e,isUninitialized:e==="uninitialized",isLoading:e==="pending",isSuccess:e==="fulfilled",isError:e==="rejected"}}function Me(e){return new RegExp("(^|:)//").test(e)}var yt=e=>e.replace(/\/$/,""),dt=e=>e.replace(/^\//,"");function ke(e,n){if(!e)return n;if(!n)return e;if(Me(n))return n;let p=e.endsWith("/")||!n.startsWith("?")?"/":"";return e=yt(e),n=dt(n),`${e}${p}${n}`}var Qe=e=>[].concat(...e);function ve(){return typeof navigator>"u"||navigator.onLine===void 0?!0:navigator.onLine}function Be(){return typeof document>"u"?!0:document.visibilityState!=="hidden"}import{createAction as H,createSlice as V,createSelector as Pe,createAsyncThunk as Re,combineReducers as Fe,createNextState as ne,isAnyOf as re,isAllOf as ue,isAction as we,isPending as ye,isRejected as J,isFulfilled as q,isRejectedWithValue as G,isAsyncThunkAction as xe,prepareAutoBatched as Y,SHOULD_AUTOBATCH as ie,isPlainObject as L,nanoid as Ce}from"@reduxjs/toolkit";var Ie=L;function de(e,n){if(e===n||!(Ie(e)&&Ie(n)||Array.isArray(e)&&Array.isArray(n)))return n;let p=Object.keys(n),Q=Object.keys(e),f=p.length===Q.length,R=Array.isArray(n)?[]:{};for(let S of p)R[S]=de(e[S],n[S]),f&&(f=e[S]===R[S]);return f?e:R}var Oe=(...e)=>fetch(...e),pt=e=>e.status>=200&&e.status<=299,ct=e=>/ion\/(vnd\.api\+)?json/.test(e.get("content-type")||"");function qe(e){if(!L(e))return e;let n={...e};for(let[p,Q]of Object.entries(n))Q===void 0&&delete n[p];return n}function lt({baseUrl:e,prepareHeaders:n=y=>y,fetchFn:p=Oe,paramsSerializer:Q,isJsonContentType:f=ct,jsonContentType:R="application/json",jsonReplacer:S,timeout:b,responseHandler:M,validateStatus:m,...g}={}){return typeof fetch>"u"&&p===Oe&&console.warn("Warning: `fetch` is not available. Please supply a custom `fetchFn` property to use `fetchBaseQuery` on SSR environments."),async(i,t)=>{let{signal:d,getState:x,extra:c,endpoint:u,forced:o,type:a}=t,r,{url:s,headers:T=new Headers(g.headers),params:l=void 0,responseHandler:h=M??"json",validateStatus:E=m??pt,timeout:A=b,...k}=typeof i=="string"?{url:i}:i,D={...g,signal:d,...k};T=new Headers(qe(T)),D.headers=await n(T,{getState:x,extra:c,endpoint:u,forced:o,type:a})||T;let v=P=>typeof P=="object"&&(L(P)||Array.isArray(P)||typeof P.toJSON=="function");if(!D.headers.has("content-type")&&v(D.body)&&D.headers.set("content-type",R),v(D.body)&&f(D.headers)&&(D.body=JSON.stringify(D.body,S)),l){let P=~s.indexOf("?")?"&":"?",F=Q?Q(l):new URLSearchParams(qe(l));s+=P+F}s=ke(e,s);let B=new Request(s,D);r={request:new Request(s,D)};let I,N=!1,C=A&&setTimeout(()=>{N=!0,t.abort()},A);try{I=await p(B)}catch(P){return{error:{status:N?"TIMEOUT_ERROR":"FETCH_ERROR",error:String(P)},meta:r}}finally{C&&clearTimeout(C)}let K=I.clone();r.response=K;let O,te="";try{let P;if(await Promise.all([y(I,h).then(F=>O=F,F=>P=F),K.text().then(F=>te=F,()=>{})]),P)throw P}catch(P){return{error:{status:"PARSING_ERROR",originalStatus:I.status,data:te,error:String(P)},meta:r}}return E(I,O)?{data:O,meta:r}:{error:{status:I.status,data:O},meta:r}};async function y(i,t){if(typeof t=="function")return t(i);if(t==="content-type"&&(t=f(i.headers)?"json":"text"),t==="json"){let d=await i.text();return d.length?JSON.parse(d):null}return i.text()}}var j=class{constructor(n,p=void 0){this.value=n;this.meta=p}};async function ft(e=0,n=5){let p=Math.min(e,n),Q=~~((Math.random()+.4)*(300<<p));await new Promise(f=>setTimeout(R=>f(R),Q))}function mt(e){throw Object.assign(new j({error:e}),{throwImmediately:!0})}var Ne={},gt=(e,n)=>async(p,Q,f)=>{let R=[5,(n||Ne).maxRetries,(f||Ne).maxRetries].filter(g=>g!==void 0),[S]=R.slice(-1),M={maxRetries:S,backoff:ft,retryCondition:(g,y,{attempt:i})=>i<=S,...n,...f},m=0;for(;;)try{let g=await e(p,Q,f);if(g.error)throw new j(g);return g}catch(g){if(m++,g.throwImmediately){if(g instanceof j)return g.value;throw g}if(g instanceof j&&!M.retryCondition(g.value.error,p,{attempt:m,baseQueryApi:Q,extraOptions:f}))return g.value;await M.backoff(m,M.maxRetries)}},Tt=Object.assign(gt,{fail:mt});var z=H("__rtkq/focused"),X=H("__rtkq/unfocused"),W=H("__rtkq/online"),Z=H("__rtkq/offline"),Se=!1;function ht(e,n){function p(){let Q=()=>e(z()),f=()=>e(X()),R=()=>e(W()),S=()=>e(Z()),b=()=>{window.document.visibilityState==="visible"?Q():f()};return Se||typeof window<"u"&&window.addEventListener&&(window.addEventListener("visibilitychange",b,!1),window.addEventListener("focus",Q,!1),window.addEventListener("online",R,!1),window.addEventListener("offline",S,!1),Se=!0),()=>{window.removeEventListener("focus",Q),window.removeEventListener("visibilitychange",b),window.removeEventListener("online",R),window.removeEventListener("offline",S),Se=!1}}return n?n(e,{onFocus:z,onFocusLost:X,onOffline:Z,onOnline:W}):p()}function ce(e){return e.type==="query"}function Ke(e){return e.type==="mutation"}function oe(e,n,p,Q,f,R){return Qt(e)?e(n,p,Q,f).map(pe).map(R):Array.isArray(e)?e.map(pe).map(R):[]}function Qt(e){return typeof e=="function"}function pe(e){return typeof e=="string"?{type:e}:e}import"@reduxjs/toolkit";function Ae(e){return e!=null}function U(e){let n=0;for(let p in e)n++;return n}function je(e,n){return e.catch(n)}var ee=Symbol("forceQueryFn"),ae=e=>typeof e[ee]=="function";function Ue({serializeQueryArgs:e,queryThunk:n,mutationThunk:p,api:Q,context:f}){let R=new Map,S=new Map,{unsubscribeQueryResult:b,removeMutationResult:M,updateSubscriptionOptions:m}=Q.internalActions;return{buildInitiateQuery:x,buildInitiateMutation:c,getRunningQueryThunk:g,getRunningMutationThunk:y,getRunningQueriesThunk:i,getRunningMutationsThunk:t};function g(u,o){return a=>{let r=f.endpointDefinitions[u],s=e({queryArgs:o,endpointDefinition:r,endpointName:u});return R.get(a)?.[s]}}function y(u,o){return a=>S.get(a)?.[o]}function i(){return u=>Object.values(R.get(u)||{}).filter(Ae)}function t(){return u=>Object.values(S.get(u)||{}).filter(Ae)}function d(u){}function x(u,o){let a=(r,{subscribe:s=!0,forceRefetch:T,subscriptionOptions:l,[ee]:h,...E}={})=>(A,k)=>{let D=e({queryArgs:r,endpointDefinition:o,endpointName:u}),v=n({...E,type:"query",subscribe:s,forceRefetch:T,subscriptionOptions:l,endpointName:u,originalArgs:r,queryCacheKey:D,[ee]:h}),B=Q.endpoints[u].select(r),w=A(v),I=B(k());let{requestId:N,abort:C}=w,K=I.requestId!==N,O=R.get(A)?.[D],te=()=>B(k()),P=Object.assign(h?w.then(te):K&&!O?Promise.resolve(I):Promise.all([O,w]).then(te),{arg:r,requestId:N,subscriptionOptions:l,queryCacheKey:D,abort:C,async unwrap(){let F=await P;if(F.isError)throw F.error;return F.data},refetch:()=>A(a(r,{subscribe:!1,forceRefetch:!0})),unsubscribe(){s&&A(b({queryCacheKey:D,requestId:N}))},updateSubscriptionOptions(F){P.subscriptionOptions=F,A(m({endpointName:u,requestId:N,queryCacheKey:D,options:F}))}});if(!O&&!K&&!h){let F=R.get(A)||{};F[D]=P,R.set(A,F),P.then(()=>{delete F[D],U(F)||R.delete(A)})}return P};return a}function c(u){return(o,{track:a=!0,fixedCacheKey:r}={})=>(s,T)=>{let l=p({type:"mutation",endpointName:u,originalArgs:o,track:a,fixedCacheKey:r}),h=s(l);let{requestId:E,abort:A,unwrap:k}=h,D=je(h.unwrap().then(I=>({data:I})),I=>({error:I})),v=()=>{s(M({requestId:E,fixedCacheKey:r}))},B=Object.assign(D,{arg:h.arg,requestId:E,abort:A,unwrap:k,reset:v}),w=S.get(s)||{};return S.set(s,w),w[E]=B,B.then(()=>{delete w[E],U(w)||S.delete(s)}),r&&(w[r]=B,B.then(()=>{w[r]===B&&(delete w[r],U(w)||S.delete(s))})),B}}}import{isDraftable as Rt,produceWithPatches as xt}from"immer";function He(e){return e}function _e({reducerPath:e,baseQuery:n,context:{endpointDefinitions:p},serializeQueryArgs:Q,api:f,assertTagType:R}){let S=(o,a,r,s)=>(T,l)=>{let h=p[o],E=Q({queryArgs:a,endpointDefinition:h,endpointName:o});if(T(f.internalActions.queryResultPatched({queryCacheKey:E,patches:r})),!s)return;let A=f.endpoints[o].select(a)(l()),k=oe(h.providesTags,A.data,void 0,a,{},R);T(f.internalActions.updateProvidedBy({queryCacheKey:E,providedTags:k}))},b=(o,a,r,s=!0)=>(T,l)=>{let E=f.endpoints[o].select(a)(l()),A={patches:[],inversePatches:[],undo:()=>T(f.util.patchQueryData(o,a,A.inversePatches,s))};if(E.status==="uninitialized")return A;let k;if("data"in E)if(Rt(E.data)){let[D,v,B]=xt(E.data,r);A.patches.push(...v),A.inversePatches.push(...B),k=D}else k=r(E.data),A.patches.push({op:"replace",path:[],value:k}),A.inversePatches.push({op:"replace",path:[],value:E.data});return T(f.util.patchQueryData(o,a,A.patches,s)),A},M=(o,a,r)=>s=>s(f.endpoints[o].initiate(a,{subscribe:!1,forceRefetch:!0,[ee]:()=>({data:r})})),m=async(o,{signal:a,abort:r,rejectWithValue:s,fulfillWithValue:T,dispatch:l,getState:h,extra:E})=>{let A=p[o.endpointName];try{let k=He,D,v={signal:a,abort:r,dispatch:l,getState:h,extra:E,endpoint:o.endpointName,type:o.type,forced:o.type==="query"?g(o,h()):void 0},B=o.type==="query"?o[ee]:void 0;if(B?D=B():A.query?(D=await n(A.query(o.originalArgs),v,A.extraOptions),A.transformResponse&&(k=A.transformResponse)):D=await A.queryFn(o.originalArgs,v,A.extraOptions,w=>n(w,v,A.extraOptions)),typeof process<"u",D.error)throw new j(D.error,D.meta);return T(await k(D.data,D.meta,o.originalArgs),{fulfilledTimeStamp:Date.now(),baseQueryMeta:D.meta,[ie]:!0})}catch(k){let D=k;if(D instanceof j){let v=He;A.query&&A.transformErrorResponse&&(v=A.transformErrorResponse);try{return s(await v(D.value,D.meta,o.originalArgs),{baseQueryMeta:D.meta,[ie]:!0})}catch(B){D=B}}throw typeof process<"u",console.error(D),D}};function g(o,a){let r=a[e]?.queries?.[o.queryCacheKey],s=a[e]?.config.refetchOnMountOrArgChange,T=r?.fulfilledTimeStamp,l=o.forceRefetch??(o.subscribe&&s);return l?l===!0||(Number(new Date)-Number(T))/1e3>=l:!1}let y=Re(`${e}/executeQuery`,m,{getPendingMeta(){return{startedTimeStamp:Date.now(),[ie]:!0}},condition(o,{getState:a}){let r=a(),s=r[e]?.queries?.[o.queryCacheKey],T=s?.fulfilledTimeStamp,l=o.originalArgs,h=s?.originalArgs,E=p[o.endpointName];return ae(o)?!0:s?.status==="pending"?!1:g(o,r)||ce(E)&&E?.forceRefetch?.({currentArg:l,previousArg:h,endpointState:s,state:r})?!0:!T},dispatchConditionRejection:!0}),i=Re(`${e}/executeMutation`,m,{getPendingMeta(){return{startedTimeStamp:Date.now(),[ie]:!0}}}),t=o=>"force"in o,d=o=>"ifOlderThan"in o,x=(o,a,r)=>(s,T)=>{let l=t(r)&&r.force,h=d(r)&&r.ifOlderThan,E=(k=!0)=>{let D={forceRefetch:k,isPrefetch:!0};return f.endpoints[o].initiate(a,D)},A=f.endpoints[o].select(a)(T());if(l)s(E());else if(h){let k=A?.fulfilledTimeStamp;if(!k){s(E());return}(Number(new Date)-Number(new Date(k)))/1e3>=h&&s(E())}else s(E(!1))};function c(o){return a=>a?.meta?.arg?.endpointName===o}function u(o,a){return{matchPending:ue(ye(o),c(a)),matchFulfilled:ue(q(o),c(a)),matchRejected:ue(J(o),c(a))}}return{queryThunk:y,mutationThunk:i,prefetch:x,updateQueryData:b,upsertQueryData:M,patchQueryData:S,buildMatchThunkActions:u}}function le(e,n,p,Q){return oe(p[e.meta.arg.endpointName][n],q(e)?e.payload:void 0,G(e)?e.payload:void 0,e.meta.arg.originalArgs,"baseQueryMeta"in e.meta?e.meta.baseQueryMeta:void 0,Q)}import{isDraft as St}from"immer";import{applyPatches as Le,original as At}from"immer";function fe(e,n,p){let Q=e[n];Q&&p(Q)}function $(e){return("arg"in e?e.arg.fixedCacheKey:e.fixedCacheKey)??e.requestId}function ze(e,n,p){let Q=e[$(n)];Q&&p(Q)}var se={};function We({reducerPath:e,queryThunk:n,mutationThunk:p,context:{endpointDefinitions:Q,apiUid:f,extractRehydrationInfo:R,hasRehydrationInfo:S},assertTagType:b,config:M}){let m=H(`${e}/resetApiState`),g=V({name:`${e}/queries`,initialState:se,reducers:{removeQueryResult:{reducer(a,{payload:{queryCacheKey:r}}){delete a[r]},prepare:Y()},queryResultPatched:{reducer(a,{payload:{queryCacheKey:r,patches:s}}){fe(a,r,T=>{T.data=Le(T.data,s.concat())})},prepare:Y()}},extraReducers(a){a.addCase(n.pending,(r,{meta:s,meta:{arg:T}})=>{let l=ae(T);r[T.queryCacheKey]??={status:"uninitialized",endpointName:T.endpointName},fe(r,T.queryCacheKey,h=>{h.status="pending",h.requestId=l&&h.requestId?h.requestId:s.requestId,T.originalArgs!==void 0&&(h.originalArgs=T.originalArgs),h.startedTimeStamp=s.startedTimeStamp})}).addCase(n.fulfilled,(r,{meta:s,payload:T})=>{fe(r,s.arg.queryCacheKey,l=>{if(l.requestId!==s.requestId&&!ae(s.arg))return;let{merge:h}=Q[s.arg.endpointName];if(l.status="fulfilled",h)if(l.data!==void 0){let{fulfilledTimeStamp:E,arg:A,baseQueryMeta:k,requestId:D}=s,v=ne(l.data,B=>h(B,T,{arg:A.originalArgs,baseQueryMeta:k,fulfilledTimeStamp:E,requestId:D}));l.data=v}else l.data=T;else l.data=Q[s.arg.endpointName].structuralSharing??!0?de(St(l.data)?At(l.data):l.data,T):T;delete l.error,l.fulfilledTimeStamp=s.fulfilledTimeStamp})}).addCase(n.rejected,(r,{meta:{condition:s,arg:T,requestId:l},error:h,payload:E})=>{fe(r,T.queryCacheKey,A=>{if(!s){if(A.requestId!==l)return;A.status="rejected",A.error=E??h}})}).addMatcher(S,(r,s)=>{let{queries:T}=R(s);for(let[l,h]of Object.entries(T))(h?.status==="fulfilled"||h?.status==="rejected")&&(r[l]=h)})}}),y=V({name:`${e}/mutations`,initialState:se,reducers:{removeMutationResult:{reducer(a,{payload:r}){let s=$(r);s in a&&delete a[s]},prepare:Y()}},extraReducers(a){a.addCase(p.pending,(r,{meta:s,meta:{requestId:T,arg:l,startedTimeStamp:h}})=>{l.track&&(r[$(s)]={requestId:T,status:"pending",endpointName:l.endpointName,startedTimeStamp:h})}).addCase(p.fulfilled,(r,{payload:s,meta:T})=>{T.arg.track&&ze(r,T,l=>{l.requestId===T.requestId&&(l.status="fulfilled",l.data=s,l.fulfilledTimeStamp=T.fulfilledTimeStamp)})}).addCase(p.rejected,(r,{payload:s,error:T,meta:l})=>{l.arg.track&&ze(r,l,h=>{h.requestId===l.requestId&&(h.status="rejected",h.error=s??T)})}).addMatcher(S,(r,s)=>{let{mutations:T}=R(s);for(let[l,h]of Object.entries(T))(h?.status==="fulfilled"||h?.status==="rejected")&&l!==h?.requestId&&(r[l]=h)})}}),i=V({name:`${e}/invalidation`,initialState:se,reducers:{updateProvidedBy:{reducer(a,r){let{queryCacheKey:s,providedTags:T}=r.payload;for(let l of Object.values(a))for(let h of Object.values(l)){let E=h.indexOf(s);E!==-1&&h.splice(E,1)}for(let{type:l,id:h}of T){let E=(a[l]??={})[h||"__internal_without_id"]??=[];E.includes(s)||E.push(s)}},prepare:Y()}},extraReducers(a){a.addCase(g.actions.removeQueryResult,(r,{payload:{queryCacheKey:s}})=>{for(let T of Object.values(r))for(let l of Object.values(T)){let h=l.indexOf(s);h!==-1&&l.splice(h,1)}}).addMatcher(S,(r,s)=>{let{provided:T}=R(s);for(let[l,h]of Object.entries(T))for(let[E,A]of Object.entries(h)){let k=(r[l]??={})[E||"__internal_without_id"]??=[];for(let D of A)k.includes(D)||k.push(D)}}).addMatcher(re(q(n),G(n)),(r,s)=>{let T=le(s,"providesTags",Q,b),{queryCacheKey:l}=s.meta.arg;i.caseReducers.updateProvidedBy(r,i.actions.updateProvidedBy({queryCacheKey:l,providedTags:T}))})}}),t=V({name:`${e}/subscriptions`,initialState:se,reducers:{updateSubscriptionOptions(a,r){},unsubscribeQueryResult(a,r){},internal_getRTKQSubscriptions(){}}}),d=V({name:`${e}/internalSubscriptions`,initialState:se,reducers:{subscriptionsUpdated:{reducer(a,r){return Le(a,r.payload)},prepare:Y()}}}),x=V({name:`${e}/config`,initialState:{online:ve(),focused:Be(),middlewareRegistered:!1,...M},reducers:{middlewareRegistered(a,{payload:r}){a.middlewareRegistered=a.middlewareRegistered==="conflict"||f!==r?"conflict":!0}},extraReducers:a=>{a.addCase(W,r=>{r.online=!0}).addCase(Z,r=>{r.online=!1}).addCase(z,r=>{r.focused=!0}).addCase(X,r=>{r.focused=!1}).addMatcher(S,r=>({...r}))}}),c=Fe({queries:g.reducer,mutations:y.reducer,provided:i.reducer,subscriptions:d.reducer,config:x.reducer}),u=(a,r)=>c(m.match(r)?void 0:a,r),o={...x.actions,...g.actions,...t.actions,...d.actions,...y.actions,...i.actions,resetApiState:m};return{reducer:u,actions:o}}var me=Symbol.for("RTKQ/skipToken"),Je={status:"uninitialized"},Ve=ne(Je,()=>{}),$e=ne(Je,()=>{});function Ge({serializeQueryArgs:e,reducerPath:n,createSelector:p}){let Q=y=>Ve,f=y=>$e;return{buildQuerySelector:b,buildMutationSelector:M,selectInvalidatedBy:m,selectCachedArgsForQuery:g};function R(y){return{...y,...Ee(y.status)}}function S(y){return y[n]}function b(y,i){return t=>{let d=e({queryArgs:t,endpointDefinition:i,endpointName:y});return p(t===me?Q:u=>S(u)?.queries?.[d]??Ve,R)}}function M(){return y=>{let i;return typeof y=="object"?i=$(y)??me:i=y,p(i===me?f:x=>S(x)?.mutations?.[i]??$e,R)}}function m(y,i){let t=y[n],d=new Set;for(let x of i.map(pe)){let c=t.provided[x.type];if(!c)continue;let u=(x.id!==void 0?c[x.id]:Qe(Object.values(c)))??[];for(let o of u)d.add(o)}return Qe(Array.from(d.values()).map(x=>{let c=t.queries[x];return c?[{queryCacheKey:x,endpointName:c.endpointName,originalArgs:c.originalArgs}]:[]}))}function g(y,i){return Object.values(y[n].queries).filter(t=>t?.endpointName===i&&t.status!=="uninitialized").map(t=>t.originalArgs)}}import{formatProdErrorMessage as Dt}from"@reduxjs/toolkit";var Ye=WeakMap?new WeakMap:void 0,ge=({endpointName:e,queryArgs:n})=>{let p="",Q=Ye?.get(n);if(typeof Q=="string")p=Q;else{let f=JSON.stringify(n,(R,S)=>L(S)?Object.keys(S).sort().reduce((b,M)=>(b[M]=S[M],b),{}):S);L(n)&&Ye?.set(n,f),p=f}return`${e}(${p})`};import{weakMapMemoize as Xe}from"reselect";function De(...e){return function(p){let Q=Xe(m=>p.extractRehydrationInfo?.(m,{reducerPath:p.reducerPath??"api"})),f={reducerPath:"api",keepUnusedDataFor:60,refetchOnMountOrArgChange:!1,refetchOnFocus:!1,refetchOnReconnect:!1,invalidationBehavior:"delayed",...p,extractRehydrationInfo:Q,serializeQueryArgs(m){let g=ge;if("serializeQueryArgs"in m.endpointDefinition){let y=m.endpointDefinition.serializeQueryArgs;g=i=>{let t=y(i);return typeof t=="string"?t:ge({...i,queryArgs:t})}}else p.serializeQueryArgs&&(g=p.serializeQueryArgs);return g(m)},tagTypes:[...p.tagTypes||[]]},R={endpointDefinitions:{},batch(m){m()},apiUid:Ce(),extractRehydrationInfo:Q,hasRehydrationInfo:Xe(m=>Q(m)!=null)},S={injectEndpoints:M,enhanceEndpoints({addTagTypes:m,endpoints:g}){if(m)for(let y of m)f.tagTypes.includes(y)||f.tagTypes.push(y);if(g)for(let[y,i]of Object.entries(g))typeof i=="function"?i(R.endpointDefinitions[y]):Object.assign(R.endpointDefinitions[y]||{},i);return S}},b=e.map(m=>m.init(S,f,R));function M(m){let g=m.endpoints({query:y=>({...y,type:"query"}),mutation:y=>({...y,type:"mutation"})});for(let[y,i]of Object.entries(g)){if(m.overrideExisting!==!0&&y in R.endpointDefinitions){if(m.overrideExisting==="throw")throw new Error(Dt(39));typeof process<"u";continue}R.endpointDefinitions[y]=i;for(let t of b)t.injectEndpoint(y,i)}return S}return S.injectEndpoints({endpoints:p.endpoints})}}import{formatProdErrorMessage as bt}from"@reduxjs/toolkit";function Et(){return function(){throw new Error(bt(33))}}function Mt(e){for(let n in e)return!1;return!0}var kt=2147483647/1e3-1,Ze=({reducerPath:e,api:n,context:p,internalState:Q})=>{let{removeQueryResult:f,unsubscribeQueryResult:R}=n.internalActions;function S(g){let y=Q.currentSubscriptions[g];return!!y&&!Mt(y)}let b={},M=(g,y,i)=>{if(R.match(g)){let t=y.getState()[e],{queryCacheKey:d}=g.payload;m(d,t.queries[d]?.endpointName,y,t.config)}if(n.util.resetApiState.match(g))for(let[t,d]of Object.entries(b))d&&clearTimeout(d),delete b[t];if(p.hasRehydrationInfo(g)){let t=y.getState()[e],{queries:d}=p.extractRehydrationInfo(g);for(let[x,c]of Object.entries(d))m(x,c?.endpointName,y,t.config)}};function m(g,y,i,t){let x=p.endpointDefinitions[y]?.keepUnusedDataFor??t.keepUnusedDataFor;if(x===1/0)return;let c=Math.max(0,Math.min(x,kt));if(!S(g)){let u=b[g];u&&clearTimeout(u),b[g]=setTimeout(()=>{S(g)||i.dispatch(f({queryCacheKey:g})),delete b[g]},c*1e3)}}return M};var et=({reducerPath:e,context:n,context:{endpointDefinitions:p},mutationThunk:Q,queryThunk:f,api:R,assertTagType:S,refetchQuery:b,internalState:M})=>{let{removeQueryResult:m}=R.internalActions,g=re(q(Q),G(Q)),y=re(q(Q,f),J(Q,f)),i=[],t=(c,u)=>{g(c)?x(le(c,"invalidatesTags",p,S),u):y(c)?x([],u):R.util.invalidateTags.match(c)&&x(oe(c.payload,void 0,void 0,void 0,void 0,S),u)};function d(c){for(let u in c.queries)if(c.queries[u]?.status==="pending")return!0;for(let u in c.mutations)if(c.mutations[u]?.status==="pending")return!0;return!1}function x(c,u){let o=u.getState(),a=o[e];if(i.push(...c),a.config.invalidationBehavior==="delayed"&&d(a))return;let r=i;if(i=[],r.length===0)return;let s=R.util.selectInvalidatedBy(o,r);n.batch(()=>{let T=Array.from(s.values());for(let{queryCacheKey:l}of T){let h=a.queries[l],E=M.currentSubscriptions[l]??{};h&&(U(E)===0?u.dispatch(m({queryCacheKey:l})):h.status!=="uninitialized"&&u.dispatch(b(h,l)))}})}return t};var tt=({reducerPath:e,queryThunk:n,api:p,refetchQuery:Q,internalState:f})=>{let R={},S=(i,t)=>{(p.internalActions.updateSubscriptionOptions.match(i)||p.internalActions.unsubscribeQueryResult.match(i))&&M(i.payload,t),(n.pending.match(i)||n.rejected.match(i)&&i.meta.condition)&&M(i.meta.arg,t),(n.fulfilled.match(i)||n.rejected.match(i)&&!i.meta.condition)&&b(i.meta.arg,t),p.util.resetApiState.match(i)&&g()};function b({queryCacheKey:i},t){let d=t.getState()[e],x=d.queries[i],c=f.currentSubscriptions[i];if(!x||x.status==="uninitialized")return;let{lowestPollingInterval:u,skipPollingIfUnfocused:o}=y(c);if(!Number.isFinite(u))return;let a=R[i];a?.timeout&&(clearTimeout(a.timeout),a.timeout=void 0);let r=Date.now()+u;R[i]={nextPollTimestamp:r,pollingInterval:u,timeout:setTimeout(()=>{(d.config.focused||!o)&&t.dispatch(Q(x,i)),b({queryCacheKey:i},t)},u)}}function M({queryCacheKey:i},t){let x=t.getState()[e].queries[i],c=f.currentSubscriptions[i];if(!x||x.status==="uninitialized")return;let{lowestPollingInterval:u}=y(c);if(!Number.isFinite(u)){m(i);return}let o=R[i],a=Date.now()+u;(!o||a<o.nextPollTimestamp)&&b({queryCacheKey:i},t)}function m(i){let t=R[i];t?.timeout&&clearTimeout(t.timeout),delete R[i]}function g(){for(let i of Object.keys(R))m(i)}function y(i={}){let t=!1,d=Number.POSITIVE_INFINITY;for(let x in i)i[x].pollingInterval&&(d=Math.min(i[x].pollingInterval,d),t=i[x].skipPollingIfUnfocused||t);return{lowestPollingInterval:d,skipPollingIfUnfocused:t}}return S};var nt=({reducerPath:e,context:n,api:p,refetchQuery:Q,internalState:f})=>{let{removeQueryResult:R}=p.internalActions,S=(M,m)=>{z.match(M)&&b(m,"refetchOnFocus"),W.match(M)&&b(m,"refetchOnReconnect")};function b(M,m){let g=M.getState()[e],y=g.queries,i=f.currentSubscriptions;n.batch(()=>{for(let t of Object.keys(i)){let d=y[t],x=i[t];if(!x||!d)continue;(Object.values(x).some(u=>u[m]===!0)||Object.values(x).every(u=>u[m]===void 0)&&g.config[m])&&(U(x)===0?M.dispatch(R({queryCacheKey:t})):d.status!=="uninitialized"&&M.dispatch(Q(d,t)))}})}return S};var rt=new Error("Promise never resolved before cacheEntryRemoved."),it=({api:e,reducerPath:n,context:p,queryThunk:Q,mutationThunk:f,internalState:R})=>{let S=xe(Q),b=xe(f),M=q(Q,f),m={},g=(t,d,x)=>{let c=y(t);if(Q.pending.match(t)){let u=x[n].queries[c],o=d.getState()[n].queries[c];!u&&o&&i(t.meta.arg.endpointName,t.meta.arg.originalArgs,c,d,t.meta.requestId)}else if(f.pending.match(t))d.getState()[n].mutations[c]&&i(t.meta.arg.endpointName,t.meta.arg.originalArgs,c,d,t.meta.requestId);else if(M(t)){let u=m[c];u?.valueResolved&&(u.valueResolved({data:t.payload,meta:t.meta.baseQueryMeta}),delete u.valueResolved)}else if(e.internalActions.removeQueryResult.match(t)||e.internalActions.removeMutationResult.match(t)){let u=m[c];u&&(delete m[c],u.cacheEntryRemoved())}else if(e.util.resetApiState.match(t))for(let[u,o]of Object.entries(m))delete m[u],o.cacheEntryRemoved()};function y(t){return S(t)?t.meta.arg.queryCacheKey:b(t)?t.meta.arg.fixedCacheKey??t.meta.requestId:e.internalActions.removeQueryResult.match(t)?t.payload.queryCacheKey:e.internalActions.removeMutationResult.match(t)?$(t.payload):""}function i(t,d,x,c,u){let o=p.endpointDefinitions[t],a=o?.onCacheEntryAdded;if(!a)return;let r={},s=new Promise(k=>{r.cacheEntryRemoved=k}),T=Promise.race([new Promise(k=>{r.valueResolved=k}),s.then(()=>{throw rt})]);T.catch(()=>{}),m[x]=r;let l=e.endpoints[t].select(o.type==="query"?d:x),h=c.dispatch((k,D,v)=>v),E={...c,getCacheEntry:()=>l(c.getState()),requestId:u,extra:h,updateCachedData:o.type==="query"?k=>c.dispatch(e.util.updateQueryData(t,d,k)):void 0,cacheDataLoaded:T,cacheEntryRemoved:s},A=a(d,E);Promise.resolve(A).catch(k=>{if(k!==rt)throw k})}return g};var ot=({api:e,context:n,queryThunk:p,mutationThunk:Q})=>{let f=ye(p,Q),R=J(p,Q),S=q(p,Q),b={};return(m,g)=>{if(f(m)){let{requestId:y,arg:{endpointName:i,originalArgs:t}}=m.meta,d=n.endpointDefinitions[i],x=d?.onQueryStarted;if(x){let c={},u=new Promise((s,T)=>{c.resolve=s,c.reject=T});u.catch(()=>{}),b[y]=c;let o=e.endpoints[i].select(d.type==="query"?t:y),a=g.dispatch((s,T,l)=>l),r={...g,getCacheEntry:()=>o(g.getState()),requestId:y,extra:a,updateCachedData:d.type==="query"?s=>g.dispatch(e.util.updateQueryData(i,t,s)):void 0,queryFulfilled:u};x(t,r)}}else if(S(m)){let{requestId:y,baseQueryMeta:i}=m.meta;b[y]?.resolve({data:m.payload,meta:i}),delete b[y]}else if(R(m)){let{requestId:y,rejectedWithValue:i,baseQueryMeta:t}=m.meta;b[y]?.reject({error:m.payload??m.error,isUnhandledError:!i,meta:t}),delete b[y]}}};var at=({api:e,context:{apiUid:n},reducerPath:p})=>(Q,f)=>{e.util.resetApiState.match(Q)&&f.dispatch(e.internalActions.middlewareRegistered(n)),typeof process<"u"};import{produceWithPatches as vt}from"immer";var st=({api:e,queryThunk:n,internalState:p})=>{let Q=`${e.reducerPath}/subscriptions`,f=null,R=null,{updateSubscriptionOptions:S,unsubscribeQueryResult:b}=e.internalActions,M=(t,d)=>{if(S.match(d)){let{queryCacheKey:c,requestId:u,options:o}=d.payload;return t?.[c]?.[u]&&(t[c][u]=o),!0}if(b.match(d)){let{queryCacheKey:c,requestId:u}=d.payload;return t[c]&&delete t[c][u],!0}if(e.internalActions.removeQueryResult.match(d))return delete t[d.payload.queryCacheKey],!0;if(n.pending.match(d)){let{meta:{arg:c,requestId:u}}=d,o=t[c.queryCacheKey]??={};return o[`${u}_running`]={},c.subscribe&&(o[u]=c.subscriptionOptions??o[u]??{}),!0}let x=!1;if(n.fulfilled.match(d)||n.rejected.match(d)){let c=t[d.meta.arg.queryCacheKey]||{},u=`${d.meta.requestId}_running`;x||=!!c[u],delete c[u]}if(n.rejected.match(d)){let{meta:{condition:c,arg:u,requestId:o}}=d;if(c&&u.subscribe){let a=t[u.queryCacheKey]??={};a[o]=u.subscriptionOptions??a[o]??{},x=!0}}return x},m=()=>p.currentSubscriptions,i={getSubscriptions:m,getSubscriptionCount:t=>{let x=m()[t]??{};return U(x)},isRequestSubscribed:(t,d)=>!!m()?.[t]?.[d]};return(t,d)=>{if(f||(f=JSON.parse(JSON.stringify(p.currentSubscriptions))),e.util.resetApiState.match(t))return f=p.currentSubscriptions={},R=null,[!0,!1];if(e.internalActions.internal_getRTKQSubscriptions.match(t))return[!1,i];let x=M(p.currentSubscriptions,t),c=!0;if(x){R||(R=setTimeout(()=>{let a=JSON.parse(JSON.stringify(p.currentSubscriptions)),[,r]=vt(f,()=>a);d.next(e.internalActions.subscriptionsUpdated(r)),f=a,R=null},500));let u=typeof t.type=="string"&&!!t.type.startsWith(Q),o=n.rejected.match(t)&&t.meta.condition&&!!t.meta.arg.subscribe;c=!u&&!o}return[c,!1]}};function ut(e){let{reducerPath:n,queryThunk:p,api:Q,context:f}=e,{apiUid:R}=f,S={invalidateTags:H(`${n}/invalidateTags`)},b=y=>y.type.startsWith(`${n}/`),M=[at,Ze,et,tt,it,ot];return{middleware:y=>{let i=!1,d={...e,internalState:{currentSubscriptions:{}},refetchQuery:g,isThisApiSliceAction:b},x=M.map(o=>o(d)),c=st(d),u=nt(d);return o=>a=>{if(!we(a))return o(a);i||(i=!0,y.dispatch(Q.internalActions.middlewareRegistered(R)));let r={...y,next:o},s=y.getState(),[T,l]=c(a,r,s),h;if(T?h=o(a):h=l,y.getState()[n]&&(u(a,r,s),b(a)||f.hasRehydrationInfo(a)))for(let E of x)E(a,r,s);return h}},actions:S};function g(y,i,t={}){return p({type:"query",endpointName:y.endpointName,originalArgs:y.originalArgs,subscribe:!1,forceRefetch:!0,queryCacheKey:i,...t})}}function _(e,...n){return Object.assign(e,...n)}import{enablePatches as Bt}from"immer";var Te=Symbol(),be=({createSelector:e=Pe}={})=>({name:Te,init(n,{baseQuery:p,tagTypes:Q,reducerPath:f,serializeQueryArgs:R,keepUnusedDataFor:S,refetchOnMountOrArgChange:b,refetchOnFocus:M,refetchOnReconnect:m,invalidationBehavior:g},y){Bt();let i=C=>(typeof process<"u",C);Object.assign(n,{reducerPath:f,endpoints:{},internalActions:{onOnline:W,onOffline:Z,onFocus:z,onFocusLost:X},util:{}});let{queryThunk:t,mutationThunk:d,patchQueryData:x,updateQueryData:c,upsertQueryData:u,prefetch:o,buildMatchThunkActions:a}=_e({baseQuery:p,reducerPath:f,context:y,api:n,serializeQueryArgs:R,assertTagType:i}),{reducer:r,actions:s}=We({context:y,queryThunk:t,mutationThunk:d,reducerPath:f,assertTagType:i,config:{refetchOnFocus:M,refetchOnReconnect:m,refetchOnMountOrArgChange:b,keepUnusedDataFor:S,reducerPath:f,invalidationBehavior:g}});_(n.util,{patchQueryData:x,updateQueryData:c,upsertQueryData:u,prefetch:o,resetApiState:s.resetApiState}),_(n.internalActions,s);let{middleware:T,actions:l}=ut({reducerPath:f,context:y,queryThunk:t,mutationThunk:d,api:n,assertTagType:i});_(n.util,l),_(n,{reducer:r,middleware:T});let{buildQuerySelector:h,buildMutationSelector:E,selectInvalidatedBy:A,selectCachedArgsForQuery:k}=Ge({serializeQueryArgs:R,reducerPath:f,createSelector:e});_(n.util,{selectInvalidatedBy:A,selectCachedArgsForQuery:k});let{buildInitiateQuery:D,buildInitiateMutation:v,getRunningMutationThunk:B,getRunningMutationsThunk:w,getRunningQueriesThunk:I,getRunningQueryThunk:N}=Ue({queryThunk:t,mutationThunk:d,api:n,serializeQueryArgs:R,context:y});return _(n.util,{getRunningMutationThunk:B,getRunningMutationsThunk:w,getRunningQueryThunk:N,getRunningQueriesThunk:I}),{name:Te,injectEndpoint(C,K){let O=n;O.endpoints[C]??={},ce(K)?_(O.endpoints[C],{name:C,select:h(C,K),initiate:D(C,K)},a(t,C)):Ke(K)&&_(O.endpoints[C],{name:C,select:E(),initiate:v(C)},a(d,C))}}}});var Pt=De(be());export{he as QueryStatus,De as buildCreateApi,de as copyWithStructuralSharing,be as coreModule,Te as coreModuleName,Pt as createApi,ge as defaultSerializeQueryArgs,Et as fakeBaseQuery,lt as fetchBaseQuery,Tt as retry,ht as setupListeners,me as skipToken};
//# sourceMappingURL=rtk-query.browser.mjs.map